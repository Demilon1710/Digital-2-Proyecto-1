//******************************************/
// Universidad del Valle de Guatemala
// BE3029 - Electronica Digital 2
// Javier de León
// 18/08/2025
// Proyecto 1
// MCU: ESP32 dev kit 1.0
//******************************************/
//******************************************/
// Librerias
//******************************************/
#include <Arduino.h>
#include <stdint.h>
#include<driver/ledc.h>
#include "display7.h"
#include "config.h"
//******************************************/
// Definiciones
//******************************************/
#define LM35PIN 34 //Pin para el LM35
#define BTN1 13 //Pin para el botón
#define antiBounce 200 //Milisegundos para antirrebote
#define LEDB 15 //Led azul 
#define LEDY 2 //Led amarillo 
#define LEDR 4 //Led rojo 
#define servo 5
//Nombres y valores iniciales para los PWMs
#define pwmB 0
#define pwmY 1
#define pwmR 2
#define pwmS 3
//Valor para la frecuencia de PWM
#define freqPWM 50
//Valor para la resolución de PWM
#define resPWM 12
//******************************************/
// Prototipos de funciones
//******************************************/
void initBTN1(void);
void IRAM_ATTR BTN1_ISR(void); //Funciones para interrupciones de los botones
void initPWMB(void);
void initPWMY(void);
void initPWMR(void);
void initPWMS(void);
//******************************************/
// Variables globales
//******************************************/
uint32_t dutyCycle = 0;
float LM35;
volatile bool btn1ON; //Variable booleana para marcar que se presionó el botón.
volatile int32_t lastISRbtn1 = 0; //Última presionada del botón.
int temp;
int unidad;
int decena;
int decimal;
float temperatura = 0.0;

//******************************************/
// ISRs Rutinas de Interrupcion
//******************************************/
void IRAM_ATTR BTN1_ISR(void){ //Función que permite el antirrebote.
  uint32_t tiempoActual = millis(); //Millis permite contar el tiempo desde el inicio del programa.
  if(tiempoActual - lastISRbtn1 > antiBounce){ //Ciclo if para sumar al contador si se cumplen las condiciones del interruptor 1
  btn1ON = true;
  lastISRbtn1 = tiempoActual;
  }
}
AdafruitIO_Feed *tempCanal = io.feed("temperatura");
//******************************************/
// Configuracion
//******************************************/
void setup() {
// put your setup code here, to run once:
Serial.begin(115200);
initBTN1();  //Llamar a la función para inicializar los botones.
initPWMB(); //Llamar funciones para inicializar los PWMs
initPWMY();
initPWMR();
initPWMS();
configDisplay7();

//Bloque para porbar el funcionamiento de los displays de 7 segmentos.
/*digitalWrite(displaydecimal, HIGH);
digitalWrite(displayunidad, HIGH);
digitalWrite(displaydecena, HIGH);
desplegarNumero(8);
desplegarNumero(8);
desplegarNumero(8);*/

// wait for serial monitor to open
  while(! Serial);

  Serial.print("Connecting to Adafruit IO");

  // connect to io.adafruit.com
  io.connect();

  // wait for a connection
  while(io.status() < AIO_CONNECTED) {
    Serial.print(".");
    delay(500);
  }

  // we are connected
  Serial.println();
  Serial.println(io.statusText());

}
//******************************************/
// Loop Principal
//******************************************/
void loop() {
// put your main code here, to run repeatedly:
//Para utilizar el rango pedido por el proyecto, se actualizaó la fórmula para sumarle 12 grados que se perdían, de acuerdo al termostato del salón de laboratorio.
int adc = analogRead(LM35PIN);
float voltaje = adc*(3.3/4095);
LM35 = (voltaje*100) + 12;
//Bloque para probar el funcionamiento del servo.
//Se tuvo que conectar por separado a la fuente de voltaje VIN para que funcionara, en lugar de la de 3.3 V.
/*ledcWrite(pwmS, 103);
delay(1000);

ledcWrite(pwmS, 307);
delay(1000);

ledcWrite(pwmS, 512);
delay(1000);*/

if(btn1ON){
  Serial.println(LM35);
  btn1ON = false;
  temp = LM35*10;
  decena = temp/100;
  temp = temp - (decena*100);
  unidad = temp/10;
  temp = temp - (unidad*10);
  decimal = temp;
  if(LM35 < 22){ 
  ledcWrite(pwmB, 2000);
  ledcWrite(pwmY, 0);
  ledcWrite(pwmR, 0);
  ledcWrite(pwmS, 103); //Utilizando la frecuencia seleccionada (50), se obtiene el tiempo en ms dividiendo 1/50.
    //Sabiendo que el tiempo es 20 ms, y usando una resolución de 12 bits, se obtiene el ciclo de trabajo para 5 tiempos diferentes.
    //Los 20 ms se dividen entre el valor de 2^12 = 4096, obteniendo 0.004882813 ms
    //Para la primera posición se busca la posición a 0.5 ms del servo, por lo que este valor se divide en 0.004882813 ms para obtener el ciclo de trabajo a utilizar.

}
if(LM35 > 22 && LM35 < 25){
  ledcWrite(pwmB, 0);
  ledcWrite(pwmY, 2000);
  ledcWrite(pwmR, 0);
  ledcWrite(pwmS, 307);
    //Para la segunda posición se busca la posición a 1.5 ms del servo, por lo que este valor se divide en 0.004882813 ms para obtener el ciclo de trabajo a utilizar.

}
if(LM35 > 25){
  ledcWrite(pwmB, 0);
  ledcWrite(pwmY, 0);
  ledcWrite(pwmR, 2000);
  ledcWrite(pwmS, 512);
    //Para la tercera posición se busca la posición a 2.5 ms del servo, por lo que este valor se divide en 0.004882813 ms para obtener el ciclo de trabajo a utilizar.

}



temperatura = LM35;

// save count to the 'counter' feed on Adafruit IO
  Serial.print("sending -> ");
  Serial.println(temperatura);
  tempCanal->save(temperatura);


  // Adafruit IO is rate limited for publishing, so a delay is required in
  // between feed->save events. In this example, we will wait three seconds
  // (1000 milliseconds == 1 second) during each loop.
  //delay(500);

}

digitalWrite(displaydecena, LOW);
digitalWrite(displayunidad, LOW);
digitalWrite(displaydecimal, HIGH);
desplegarNumero(decimal);
desplegarPunto(0);
delay(5);

digitalWrite(displaydecena, LOW);
digitalWrite(displayunidad, HIGH);
digitalWrite(displaydecimal, LOW);
desplegarNumero(unidad);
desplegarPunto(1);
delay(5);

digitalWrite(displaydecena, HIGH);
digitalWrite(displayunidad, LOW);
digitalWrite(displaydecimal, LOW);
desplegarNumero(decena);
desplegarPunto(0);
delay(5); 

io.run();

}
//******************************************/
// Otras funciones
//******************************************/

//Se quitó la función de getTemp porque se quiere que la variable "LM35" esté presente para el programa constantemente, no solo cuando se imprime.
void initBTN1(void){
  //Funciones para denominar a los botones con su tipo de entrada y su interruptor.
  pinMode(BTN1, INPUT_PULLUP);
  attachInterrupt(BTN1, &BTN1_ISR, FALLING); //Se indica el pin del botón, su función de interrupción y el tipo de señal donde se interrumpe.
}
//Funciones para generar los PWMs
void initPWMB(void){
  ledcSetup(pwmB, freqPWM, resPWM);
  ledcAttachPin(LEDB, pwmB);
  ledcWrite(pwmB, 0);
}
void initPWMY(void){
  ledcSetup(pwmY, freqPWM, resPWM);
  ledcAttachPin(LEDY, pwmY);
  ledcWrite(pwmY, 0);
}
void initPWMR(void){
  ledcSetup(pwmR, freqPWM, resPWM);
  ledcAttachPin(LEDR, pwmR);
  ledcWrite(pwmR, 0);
}
void initPWMS(void){
  ledcSetup(pwmS, freqPWM, resPWM);
  ledcAttachPin(servo, pwmS);
  ledcWrite(pwmS, 0);
}
