//******************************************/
// Universidad del Valle de Guatemala
// BE3029 - Electronica Digital 2
// Javier de León
// 18/08/2025
// Proyecto 1
// MCU: ESP32 dev kit 1.0
//******************************************/
//******************************************/
// Librerias
//******************************************/
#include <Arduino.h>
#include <stdint.h>
#include<driver/ledc.h>
//#include "config.h"
//******************************************/
// Definiciones
//******************************************/
#define LM35PIN 34 //Pin para el LM35
#define BTN1 13 //Pin para el botón
#define antiBounce 200 //Milisegundos para antirrebote
#define LEDB 15 //Led azul 
#define LEDY 2 //Led amarillo 
#define LEDR 18 //Led rojo 
#define servo 21
//Nombres y valores iniciales para los PWMs
#define pwmB 0
#define pwmY 1
#define pwmR 2
#define pwmS 3
//Valor para la frecuencia de PWM
#define freqPWM 50
//Valor para la resolución de PWM
#define resPWM 12
//******************************************/
// Prototipos de funciones
//******************************************/
void initBTN1(void);
void IRAM_ATTR BTN1_ISR(void); //Funciones para interrupciones de los botones
void initPWMB(void);
void initPWMY(void);
void initPWMR(void);
void initPWMS(void);
//******************************************/
// Variables globales
//******************************************/
uint32_t dutyCycle = 0;
float temperatura;
volatile bool btn1ON; //Variable booleana para marcar que se presionó el botón.
volatile int32_t lastISRbtn1 = 0; //Última presionada del botón.
//******************************************/
// ISRs Rutinas de Interrupcion
//******************************************/
void IRAM_ATTR BTN1_ISR(void){ //Función que permite el antirrebote.
  uint32_t tiempoActual = millis(); //Millis permite contar el tiempo desde el inicio del programa.
  if(tiempoActual - lastISRbtn1 > antiBounce){ //Ciclo if para sumar al contador si se cumplen las condiciones del interruptor 1
  btn1ON = true;
  lastISRbtn1 = tiempoActual;
  }
}
//******************************************/
// Configuracion
//******************************************/
void setup() {
// put your setup code here, to run once:
Serial.begin(115200);
initBTN1();  //Llamar a la función para inicializar los botones.
initPWMB(); //Llamar funciones para inicializar los PWMs
initPWMY();
initPWMR();
initPWMS();
}
//******************************************/
// Loop Principal
//******************************************/
void loop() {
// put your main code here, to run repeatedly:
int adc = analogRead(LM35PIN);
float voltaje = adc*(3.3/4095);
temperatura = voltaje*100;
//Bloque para probar el funcionamiento del servo.
//Se tuvo que conectar por separado a la fuente de voltaje VIN para que funcionara, en lugar de la de 3.3 V.
/*ledcWrite(pwmS, 103);
delay(1000);

ledcWrite(pwmS, 307);
delay(1000);

ledcWrite(pwmS, 512);
delay(1000);*/

if(btn1ON){
  Serial.println(temperatura);
  btn1ON = false;
}
if(temperatura < 18){ //Se utilizaron valores cercanos a 18 y 20 debido a que para alcanzar 25 como se nos pide requiere mucho tiempo
                      //para calentar al tacto el sensor.
  ledcWrite(pwmB, 2000);
  ledcWrite(pwmY, 0);
  ledcWrite(pwmR, 0);
  ledcWrite(pwmS, 103); //Utilizando la frecuencia seleccionada (50), se obtiene el tiempo en ms dividiendo 1/50.
    //Sabiendo que el tiempo es 20 ms, y usando una resolución de 12 bits, se obtiene el ciclo de trabajo para 5 tiempos diferentes.
    //Los 20 ms se dividen entre el valor de 2^12 = 4096, obteniendo 0.004882813 ms
    //Para la primera posición se busca la posición a 0.5 ms del servo, por lo que este valor se divide en 0.004882813 ms para obtener el ciclo de trabajo a utilizar.

}
if(temperatura > 18 && temperatura < 20){
  ledcWrite(pwmB, 0);
  ledcWrite(pwmY, 2000);
  ledcWrite(pwmR, 0);
  ledcWrite(pwmS, 307);
    //Para la segunda posición se busca la posición a 1.5 ms del servo, por lo que este valor se divide en 0.004882813 ms para obtener el ciclo de trabajo a utilizar.

}
if(temperatura > 20){
  ledcWrite(pwmB, 0);
  ledcWrite(pwmY, 0);
  ledcWrite(pwmR, 2000);
  ledcWrite(pwmS, 512);
    //Para la tercera posición se busca la posición a 2.5 ms del servo, por lo que este valor se divide en 0.004882813 ms para obtener el ciclo de trabajo a utilizar.

}
}
//******************************************/
// Otras funciones
//******************************************/

//Se quitó la función de getTemp porque se quiere que la variable "temperatura" esté presente para el programa constantemente, no solo cuando se imprime.
void initBTN1(void){
  //Funciones para denominar a los botones con su tipo de entrada y su interruptor.
  pinMode(BTN1, INPUT_PULLUP);
  attachInterrupt(BTN1, &BTN1_ISR, FALLING); //Se indica el pin del botón, su función de interrupción y el tipo de señal donde se interrumpe.
}
//Funciones para generar los PWMs
void initPWMB(void){
  ledcSetup(pwmB, freqPWM, resPWM);
  ledcAttachPin(LEDB, pwmB);
  ledcWrite(pwmB, 0);
}
void initPWMY(void){
  ledcSetup(pwmY, freqPWM, resPWM);
  ledcAttachPin(LEDY, pwmY);
  ledcWrite(pwmY, 0);
}
void initPWMR(void){
  ledcSetup(pwmR, freqPWM, resPWM);
  ledcAttachPin(LEDR, pwmR);
  ledcWrite(pwmR, 0);
}
void initPWMS(void){
  ledcSetup(pwmS, freqPWM, resPWM);
  ledcAttachPin(servo, pwmS);
  ledcWrite(pwmS, 0);
}
