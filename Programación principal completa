//******************************************/
// Universidad del Valle de Guatemala
// BE3029 - Electronica Digital 2
// Javier de León
// 18/08/2025
// Proyecto 1
// MCU: ESP32 dev kit 1.0
//******************************************/
//******************************************/
// Librerias
//******************************************/
#include <Arduino.h>
#include <stdint.h>
#include<driver/ledc.h>
#include "display7.h" //Se incluye la librería creada para configurar las funciones que permiten el funcionamiento de los displays de 7 segmentos
#include "config.h" //Se incluye la librería creada para conectar al router de interés y a los servidores de adafruit
//******************************************/
// Definiciones
//******************************************/
#define LM35PIN 34 //Pin para el LM35
#define BTN1 13 //Pin para el botón
#define antiBounce 200 //Milisegundos para antirrebote
#define LEDB 15 //Led azul 
#define LEDY 2 //Led amarillo 
#define LEDR 4 //Led rojo 
#define servo 5 //Pin que indica movimiento del servomotor
//Nombres y valores iniciales para los PWMs
#define pwmB 0
#define pwmY 1
#define pwmR 2
#define pwmS 3
//Valor para la frecuencia de PWM
#define freqPWM 50
//Valor para la resolución de PWM
#define resPWM 12
//******************************************/
// Prototipos de funciones
//******************************************/
void initBTN1(void); //Nombre de la función para inicializar el botón
void IRAM_ATTR BTN1_ISR(void); //Función para interrupción del botón
void initPWMB(void); //Nombre de las funciones para inicializar el PWMs
void initPWMY(void);
void initPWMR(void);
void initPWMS(void);
//******************************************/
// Variables globales
//******************************************/
uint32_t dutyCycle = 0; //Valor inicial del ciclo de trabajo
float LM35; //Variable float para tomar en cuenta valores decimales
volatile bool btn1ON; //Variable booleana para marcar que se presionó el botón.
volatile int32_t lastISRbtn1 = 0; //Última presionada del botón.
int temp; //Variables enteras para obtener solo dígitos enteros
int unidad;
int decena;
int decimal;
float temperatura = 0.0; //Valor inicial para el canal de adafruit de temperatura.

//******************************************/
// ISRs Rutinas de Interrupcion
//******************************************/
void IRAM_ATTR BTN1_ISR(void){ //Función que permite el antirrebote.
  uint32_t tiempoActual = millis(); //Millis permite contar el tiempo desde el inicio del programa.
  if(tiempoActual - lastISRbtn1 > antiBounce){ //Ciclo if para sumar al contador si se cumplen las condiciones del interruptor 1
  btn1ON = true;
  lastISRbtn1 = tiempoActual;
  }
}
AdafruitIO_Feed *tempCanal = io.feed("temperatura"); //Variable para el canal de temperatura de adafruit
//******************************************/
// Configuracion
//******************************************/
void setup() {
// put your setup code here, to run once:
Serial.begin(115200);
initBTN1();  //Llamar a la función para inicializar los botones.
initPWMB(); //Llamar funciones para inicializar los PWMs
initPWMY();
initPWMR();
initPWMS();
configDisplay7(); //Llamar a la función de la librería de display7

// Esperar a que se abra el monitor serial
  while(! Serial);

  Serial.print("Connecting to Adafruit IO"); //Imprimir en el monitor hasta que conecte el adafruit

  // Función para conectar con el servidor de adafruit
  io.connect();

  // Esperando la conexión
  while(io.status() < AIO_CONNECTED) {
    Serial.print(".");
    delay(500);
  }

  // Imprimir al momento de conectarse al servidor
  Serial.println();
  Serial.println(io.statusText());

}
//******************************************/
// Loop Principal
//******************************************/
void loop() {
// put your main code here, to run repeatedly:
//Para utilizar el rango pedido por el proyecto, se actualizó la fórmula para sumarle 12 grados que se perdían, 
//de acuerdo al termostato del salón de laboratorio.
int adc = analogRead(LM35PIN); //Variable para leer el dato proveniente del LM35 a través de su respectivo pin del ESP32
float voltaje = adc*(3.3/4095); //Fórmula para cambiar la medida de voltaje a grados °C
LM35 = (voltaje*100) + 12;

//Ciclo if para introducir las instrucciones de lo que se quiere hacer cada vez que se presione el botón
if(btn1ON){
  Serial.println(LM35);
  btn1ON = false; //Se vuelve a empezar cada vez que se suelte el botón
  temp = LM35*10; //Se crea nueva función para remover el decimal del float original
  decena = temp/100; //Se obtiene el entero de la división del temp actual para obtener decenas
  temp = temp - (decena*100); //Se obtiene un nuevo temp quitándole centenas
  unidad = temp/10; //Se obtiene el entero de la división del temp actual para obtener unidades
  temp = temp - (unidad*10); //Se obtiene un nuevo temp solamente con el último dígito de unidad
  decimal = temp; //El último temp muestra el número decimal de la medida de interés

  //Se tuvo que conectar por separado a la fuente de voltaje VIN para que funcionara, en lugar de la de 3.3 V.
  if(LM35 < 22){ //Cuando la temperatura medida sea menor que 22 °C
  ledcWrite(pwmB, 2000); //Se enciende solo el led azúl, como estamos usando una resolución de 12 bits, el valor máximo de iluminación
  ledcWrite(pwmY, 0); //del led será de 4095, por lo que se usa un valor entre 0 y 4096 para que se ilumine
  ledcWrite(pwmR, 0);
  ledcWrite(pwmS, 103); //Utilizando la frecuencia seleccionada (50), se obtiene el tiempo en ms dividiendo 1/50.
    //Sabiendo que el tiempo es 20 ms, y usando una resolución de 12 bits, se obtiene el ciclo de trabajo para 5 tiempos diferentes.
    //Los 20 ms se dividen entre el valor de 2^12 = 4096, obteniendo 0.004882813 ms
    //Para la primera posición se busca la posición a 0.5 ms del servo, por lo que este valor se divide en 0.004882813 ms para obtener el ciclo de trabajo a utilizar.

}
if(LM35 > 22 && LM35 < 25){ //Cuando la temperatura medida se encuentre entre 22 y 25 °C
  ledcWrite(pwmB, 0);
  ledcWrite(pwmY, 2000); //Se enciende solo el led amarillo
  ledcWrite(pwmR, 0);
  ledcWrite(pwmS, 307);
    //Para la segunda posición se busca la posición a 1.5 ms del servo, por lo que este valor se divide en 0.004882813 ms para obtener el ciclo de trabajo a utilizar.

}
if(LM35 > 25){ //Cuando la temperatura medida sea mayor que 25 °C
  ledcWrite(pwmB, 0);
  ledcWrite(pwmY, 0);
  ledcWrite(pwmR, 2000); //Se enciende solo el led rojo
  ledcWrite(pwmS, 512);
    //Para la tercera posición se busca la posición a 2.5 ms del servo, por lo que este valor se divide en 0.004882813 ms para obtener el ciclo de trabajo a utilizar.

}



temperatura = LM35; //La variable con el nombre del feed y la lectura que se introducirá al mismo

// guardar el valor obtenido en el feed de adafruit
  Serial.print("sending -> ");
  Serial.println(temperatura); 
  tempCanal->save(temperatura); //temperatura es el nombre que se le dio al feed


  //No es necesario el delay debido a que se subirá el dato al momento de presionar el botón, no es continuo
  io.run(); //Importante para que se quiera conectar al servidor de adafruit

}
//En cada loop se corre el encendido y apagado de los displays de 7 segmentos a una velocidad lo suficientemente alta para que no
//se note un parpadeo constante
digitalWrite(displaydecena, LOW);
digitalWrite(displayunidad, LOW);
digitalWrite(displaydecimal, HIGH);
desplegarNumero(decimal); //Función de la librería de display7.h para denominar el dígito para el display
desplegarPunto(0); //Función de la librería de display7.h para señalar que no debe encenderse el punto decimal del display
delay(5); //Delay lo suficientemente visible y rápido

digitalWrite(displaydecena, LOW);
digitalWrite(displayunidad, HIGH);
digitalWrite(displaydecimal, LOW);
desplegarNumero(unidad);
desplegarPunto(1); //Función de la librería de display7.h para señalar que debe encenderse el punto decimal del display
delay(5);

digitalWrite(displaydecena, HIGH);
digitalWrite(displayunidad, LOW);
digitalWrite(displaydecimal, LOW);
desplegarNumero(decena);
desplegarPunto(0);
delay(5); 


}
//******************************************/
// Otras funciones
//******************************************/

void initBTN1(void){
  //Funciones para denominar a los botones con su tipo de entrada y su interrupción.
  pinMode(BTN1, INPUT_PULLUP); //Se señala que el botón el pullup porque una terminal se conecta a su pin y la otra a tierra.
  attachInterrupt(BTN1, &BTN1_ISR, FALLING); //Se indica el pin del botón, su función de interrupción y el tipo de señal donde se interrumpe.
}
//Funciones para generar los PWMs
void initPWMB(void){
  ledcSetup(pwmB, freqPWM, resPWM); //Setup del pwm con la frecuencia y la resolución indicada
  ledcAttachPin(LEDB, pwmB); //Unir el pin al pwm
  ledcWrite(pwmB, 0); //Valor inicial del ciclo de trabajo
}
void initPWMY(void){
  ledcSetup(pwmY, freqPWM, resPWM);
  ledcAttachPin(LEDY, pwmY);
  ledcWrite(pwmY, 0);
}
void initPWMR(void){
  ledcSetup(pwmR, freqPWM, resPWM);
  ledcAttachPin(LEDR, pwmR);
  ledcWrite(pwmR, 0);
}
void initPWMS(void){
  ledcSetup(pwmS, freqPWM, resPWM);
  ledcAttachPin(servo, pwmS);
  ledcWrite(pwmS, 0);
}
